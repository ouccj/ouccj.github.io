<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017上半年软考]]></title>
    <url>%2F2019%2F10%2F13%2F2017%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%BD%AF%E8%80%83%2F</url>
    <content type="text"><![CDATA[2017年上半年软考1、CPU 执行算术运算或者逻辑运算时，常将源操作数和结果暂存在累加器中。 程序计数器（PC）是用于存放下一条指令所在单元的地址的地方。 累加器（AC）全称累加寄存器，是一个通用寄存器。其功能是，当运算器的算术逻辑单元(ALU)执行算术或逻辑运算时，为ALU提供一个工作区。累加寄存器暂时存放ALU运算的结果信息。指令寄存器（IR）用于存放当前从主存储器读出的正在执行的一条指令。 指令寄存器（IR）用于存放当前从主存储器读出的正在执行的一条指令。 地址寄存器（AR）用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止。 2、计算机系统中常用的输入/输出控制方式有无条件传送、中断、程序查询和 DMA 方式等。当采用DMA方式时，不需要 CPU 执行程序指令来传送数据。 DMA（直接存储器访问方式），DMA将数据从一个地址空间复制到另外一个地址空间时，CPU初始化这个传输动作，传输动作本身是由DMA控制器来执行和完成。 3、系统可靠性计算 12串行系统的可靠性R=R1×R2×…×Rn并联系统的可靠性为R= 1-(1-R1)×（1-R2）×…×（1-Rn) 4、己知数据信息为 16 位，最少应附加（ ）位校验位，才能实现海明码纠错。 12^(k-1) ≥ m+k（m为信息位，k为校验位）当k=5时，31≥21等式成立。 5、关于Cache (高速缓冲存储器)的知识点： Cache 的设置并没有扩大主存的容量 Cache 的内容是主存部分内容的拷贝 Cache 的命中率并不随其容量增大线性地提高 Cache 位于主存与CPU 之间 Cache中储存的内容是主存部分内容的复本，是按程序的局部性原理选取出来的最常使用或不久将来仍将使用的内容。 6、HTTPS 使用SSL协议对报文进行封装。 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，是HTTP的安全版。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。 7、适合对大量的明文消息进行加密传输的是RC5 DES(Data Encryption Standard):数据加密标准，速度较快，适用于加密大量数据的场合； 3DES：是基于DES，对一块数据用三个不同的秘钥进行三次加密，强度更高； AES(Advanced Encryption Standard):高级加密标准，是下一代的加密算法标准，速度快，安全级别高； RSA：RSA加密算法是一种非对称加密算法，在公开秘钥加密和电子商业中RSA被广泛应用； SHA-1(安全散列算法)：能计算出一个数字消息所对应到的，长度固定的字符串的算法，SHA-1在许多安全协定中广为应用。 8、假定用户 A、 B 分别在 I1 和 I2 两个 CA 处取得了各自的证书，则I1、 I2 互换公钥是 A、 B 互信的必要条件。 如果两个证书发放机构X1和X2彼此之间已经安全的交换了公开秘钥，那么A可以获取B的公开秘钥 9、甲软件公司受乙企业委托安排公司软件设计师开发了信息系统管理软件，由于在委托开发合同中未对软件著作权归属作出明确的约定，所以该信息系统管理软件的著作权由甲享有。 委托开发：如果是接受他人委托而进行开发的软件，其著作权的归属应由委托人与受托人签订书面合同约定；如果没有签订合同，或者合同中未规定的，则其著作权由受托人享有。 由国家机关下达任务开发的软件，著作权的归属由项目任务书或合同规定，若未明确规定的，其著作权应归任务接受方所有。 10、商标注册： 卷烟、雪茄烟和由包装的烟丝必须申请商标注册，未经核准注册的，不得生产、销售。 除中草药和中药饮片以外的其他药品，都必须使用注册商标。 11、数字语音的采样频率定义为8kHZ，这是因为语音信号定义的频率最高为4kHZ 采样频率大于等于工作频率的两倍，才能在以后恢复出实际波形，防止信息的丢失。 12、在采用结构化开发方法进行软件开发时，设计阶段接口设计的主要依据需求恩熙阶段的数据流图，接口设计不得任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。 架构定义任务——定义软件的主要结构元素及其之间的关系。 数据存储设计任务——确定软件设计的文件系统的结构及数据库的表结构。 详细设计任务——确定软件各个模块内部的算法和数据结构。 13、在以阶段划分的编译过程中，判断程序语句的形式是否正确属于语法分析阶段的工作。 词法分析阶段：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词，删掉无用信息，报告分析时的错误。 语法分析阶段：语法分析器以单词符号作为输入，分析单词符号串是否形成符合规则的语法单位，如表达式、赋值、循环等，按语法规则分析检查每条语句是否有正确的逻辑结构。 语义分析阶段：主要是检查源程序是否存在语义错误，并收集类型信息供后面的代码生成阶段使用，如：赋值语句的右端的类型不匹配。表达式的除数是否为零等。 14、有关螺旋模型的说法： 它是风险驱动的，要求开发人员必须具有丰富的风险评估知识和经验。 它可以降低过多测试或测试不足带来的风险。 它不适用于大型软件开发。 15、7种内聚类型： 偶然内聚或巧合内聚 指一个模块内的各处理元素之间没有任何联系。 逻辑内聚 指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。 时间内聚 把需要同时执行的动作组合在一起形成的模块。 过程内聚 指一个模块完成多个任务，这些任务必须按指定的过程执行。 通信内聚 指模块内的所有处理元素都在同一数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据。 顺序内聚 指一个模块中的各个处理元素都密切相关于同一各功能且必须顺序执行，前一个功能元素的输出就是下一个功能的输入。 功能内聚 指模块内的所有元素共同作用完成一个功能，缺一不可。 16、在面向对象方法中，两个及以上的类组委一个类俄超类时，成为多重继承，使用它可能造成子类中存在二义性的成员。 17、采用面向对象方法进行软件开发，在分析阶段，架构师主要关注系统的行为。]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识]]></title>
    <url>%2F2019%2F09%2F16%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue.js简介什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 123456789&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 123&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 1&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】1Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 1234567891011121314151617181920212223242526272829303132333435// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 1&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cube_slam安装步骤]]></title>
    <url>%2F2019%2F09%2F02%2Fcube-slam%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[cube_slam安装步骤参照github连接：https://github.com/shichaoy/cube_slam1、Prerequisites12345678mkdir -p ~/cubeslam_ws/srccd ~/cubeslam_ws/srccatkin_init_workspace#此时出现错误1git clone https://github.com/shichaoy/cube_slamcd cube_slam 2、Compile dependency g2o1sh install_dependenices.sh 3、Compile123cd ~/cubeslam_wscatkin_make -j4#执行此命令后，出现错误2的情况。发现是需要安装eigen，安装完成后再次执行此命令，会出现错误3，其原因是没有安装ROS，安装ROS之后再次执行此命令即可。 4、Running1234cd ~/cubeslam_wssource devel/setup.bashroslaunch object_slam object_slam_example.launch#执行完此命令后会运行cube_slam程序 错误11234567891011-- BUILD TYPE:Release-- Compiling on UnixCMake Error at cmake_modules/FindBLAS.cmake:393 (message): A required library with BLAS API not found. Please specify library location.Call Stack (most recent call first): CMakeLists.txt:47 (FIND_PACKAGE)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/src/cube_slam/object_slam/Thirdparty/g2o/build/CMakeFiles/CMakeOutput.log". 错误1解决办法12sudo apt-get install libblas-dev sudo apt-get install liblapack-dev 错误2123456789101112131415161718192021222324252627ot create directory ‘build’: File exists-- BUILD TYPE:Release-- Compiling on Unix-- Looking for sgemm_-- Looking for sgemm_ - found-- A library with BLAS API found.-- Looking for cheev_-- Looking for cheev_ - found-- A library with LAPACK API found.-- Try OpenMP C flag = [-fopenmp]-- Performing Test OpenMP_FLAG_DETECTED-- Performing Test OpenMP_FLAG_DETECTED - Success-- Try OpenMP CXX flag = [-fopenmp]-- Performing Test OpenMP_FLAG_DETECTED-- Performing Test OpenMP_FLAG_DETECTED - Success-- Found OpenMP: -fopenmpCMake Error at /usr/share/cmake-3.5/Modules/FindPackageHandleStandardArgs.cmake:148 (message): Could NOT find Eigen3 (missing: EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK) (Required is at least version "3.1.0")Call Stack (most recent call first): /usr/share/cmake-3.5/Modules/FindPackageHandleStandardArgs.cmake:388 (_FPHSA_FAILURE_MESSAGE) cmake_modules/FindEigen3.cmake:82 (find_package_handle_standard_args) CMakeLists.txt:75 (FIND_PACKAGE)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/src/cube_slam/object_slam/Thirdparty/g2o/build/CMakeFiles/CMakeOutput.log". 解决错误2：安装eigen123456789#github 有个mirror,版本3.3.4 from 2017git clone https://github.com/eigenteam/eigen-git-mirror#安装cd eigen-git-mirrormkdir buildcd buildcmake ..sudo make install 错误3123456789101112131415161718192021222324252627282930313233343536373839CMake Warning at /usr/share/catkin/cmake/test/nosetests.cmake:98 (message): nosetests not found, Python tests can not be run (try installing package 'python-nose')Call Stack (most recent call first): /usr/share/catkin/cmake/all.cmake:147 (include) /usr/share/catkin/cmake/catkinConfig.cmake:20 (include) CMakeLists.txt:52 (find_package)-- catkin 0.6.16-- BUILD_SHARED_LIBS is on-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- ~~ traversing 4 packages in topological order:-- ~~ - line_lbd-- ~~ - tictoc_profiler-- ~~ - detect_3d_cuboid-- ~~ - object_slam-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- +++ processing catkin package: 'line_lbd'-- ==&gt; add_subdirectory(cube_slam/line_lbd)CMake Error at /usr/share/catkin/cmake/catkinConfig.cmake:75 (find_package): Could not find a package configuration file provided by "cmake_modules" with any of the following names: cmake_modulesConfig.cmake cmake_modules-config.cmake Add the installation prefix of "cmake_modules" to CMAKE_PREFIX_PATH or set "cmake_modules_DIR" to a directory containing one of the above files. If "cmake_modules" provides a separate development package or SDK, be sure it has been installed.Call Stack (most recent call first): cube_slam/line_lbd/CMakeLists.txt:7 (find_package)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/build/CMakeFiles/CMakeOutput.log".See also "/home/gpu1/cubeslam_ws/build/CMakeFiles/CMakeError.log".Invoking "cmake" failed 解决错误3：安装ROS参考连接：https://blog.csdn.net/whl970831/article/details/88097108123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ROS安装步骤1.将时间误差缩短到最小sudo apt-get install -y chrony ntpdatesudo ntpdate -q ntp.ubuntu.com2.在ros-latest.list添加ROS版本库sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt; /etc/apt/sources.list.d/ros-latest.list'3.设置公钥(Key)sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 0xB01FA116如果无法连接上述服务器，可以尝试hkp://pgp.mit.edu:80或者hkp://keyserver.ubuntu.com:804.更新软件包索引sudo apt-get updatesudo apt-get upgrade -y5.安装ROS Kinetic Kame（完整版-包括很多opencv的包之类的）sudo apt-get install ros-kinetic-desktop-full6.安装所有额外的rqt相关的功能包sudo apt-get install ros-kinetic-rqt*7.初始化rosdep 在使用ROS之前必须要初始化rosdepsudo rosdep initrosdep update8.安装rosinstall（启动roscore的核心） 在这里说一句，在配置环境变量时万万不可因错误，随意使用rm bashrc指令否则很容易造成环境丢失（虽然有找回的方法-extundelete安装），到时候可能只有重新配置了。sudo apt-get install python-rosinstall9.安装我们程序运行需要的服务sudo apt-get install ros-kinetic-serialsudo apt-get -y install ros-kinetic-slam-gmappingsudo apt-get -y install ros-kinetic-map-serversudo apt-get -y install ros-kinetic-amcl10.配置环境变量：echo “source /opt/ros/kinetic/setup.bash” &gt;&gt; ~/.bashrcsource ~/.bashrc11.测试安装结果roscore （新终端）看最后有没有setting /run_id to b243608a-2524-11e8-8f6c-342387e5d341process[rosout-1]: started with pid [7671]started core service [/rosout]有就成功了]]></content>
      <categories>
        <category>视觉slam</category>
      </categories>
      <tags>
        <tag>sube_slam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
