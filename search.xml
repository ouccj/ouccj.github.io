<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue基础知识]]></title>
    <url>%2F2019%2F09%2F16%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue.js简介什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 123456789&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type="button" value="开启" v-on:click="go"&gt; &lt;input type="button" value="停止" v-on:click="stop"&gt; &lt;/div&gt; Vue实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: '猥琐发育，别浪~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" v-on:click="getResult"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class="['red', 'thin', &#123;'active': isactive&#125;]"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class="&#123;red:true, italic:true, active:true, thin:true&#125;"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style="&#123;color: 'red', 'font-size': '40px'&#125;"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for="(item, i) in list"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 123&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for="(val, key, i) in userInfo"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 1&lt;p v-for="i in 10"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】1Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 1234567891011121314151617181920212223242526272829303132333435// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 1&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cube_slam安装步骤]]></title>
    <url>%2F2019%2F09%2F02%2Fcube-slam%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[cube_slam安装步骤参照github连接：https://github.com/shichaoy/cube_slam1、Prerequisites12345678mkdir -p ~/cubeslam_ws/srccd ~/cubeslam_ws/srccatkin_init_workspace#此时出现错误1git clone https://github.com/shichaoy/cube_slamcd cube_slam 2、Compile dependency g2o1sh install_dependenices.sh 3、Compile123cd ~/cubeslam_wscatkin_make -j4#执行此命令后，出现错误2的情况。发现是需要安装eigen，安装完成后再次执行此命令，会出现错误3，其原因是没有安装ROS，安装ROS之后再次执行此命令即可。 4、Running1234cd ~/cubeslam_wssource devel/setup.bashroslaunch object_slam object_slam_example.launch#执行完此命令后会运行cube_slam程序 错误11234567891011-- BUILD TYPE:Release-- Compiling on UnixCMake Error at cmake_modules/FindBLAS.cmake:393 (message): A required library with BLAS API not found. Please specify library location.Call Stack (most recent call first): CMakeLists.txt:47 (FIND_PACKAGE)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/src/cube_slam/object_slam/Thirdparty/g2o/build/CMakeFiles/CMakeOutput.log". 错误1解决办法12sudo apt-get install libblas-dev sudo apt-get install liblapack-dev 错误2123456789101112131415161718192021222324252627ot create directory ‘build’: File exists-- BUILD TYPE:Release-- Compiling on Unix-- Looking for sgemm_-- Looking for sgemm_ - found-- A library with BLAS API found.-- Looking for cheev_-- Looking for cheev_ - found-- A library with LAPACK API found.-- Try OpenMP C flag = [-fopenmp]-- Performing Test OpenMP_FLAG_DETECTED-- Performing Test OpenMP_FLAG_DETECTED - Success-- Try OpenMP CXX flag = [-fopenmp]-- Performing Test OpenMP_FLAG_DETECTED-- Performing Test OpenMP_FLAG_DETECTED - Success-- Found OpenMP: -fopenmpCMake Error at /usr/share/cmake-3.5/Modules/FindPackageHandleStandardArgs.cmake:148 (message): Could NOT find Eigen3 (missing: EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK) (Required is at least version "3.1.0")Call Stack (most recent call first): /usr/share/cmake-3.5/Modules/FindPackageHandleStandardArgs.cmake:388 (_FPHSA_FAILURE_MESSAGE) cmake_modules/FindEigen3.cmake:82 (find_package_handle_standard_args) CMakeLists.txt:75 (FIND_PACKAGE)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/src/cube_slam/object_slam/Thirdparty/g2o/build/CMakeFiles/CMakeOutput.log". 解决错误2：安装eigen123456789#github 有个mirror,版本3.3.4 from 2017git clone https://github.com/eigenteam/eigen-git-mirror#安装cd eigen-git-mirrormkdir buildcd buildcmake ..sudo make install 错误3123456789101112131415161718192021222324252627282930313233343536373839CMake Warning at /usr/share/catkin/cmake/test/nosetests.cmake:98 (message): nosetests not found, Python tests can not be run (try installing package 'python-nose')Call Stack (most recent call first): /usr/share/catkin/cmake/all.cmake:147 (include) /usr/share/catkin/cmake/catkinConfig.cmake:20 (include) CMakeLists.txt:52 (find_package)-- catkin 0.6.16-- BUILD_SHARED_LIBS is on-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- ~~ traversing 4 packages in topological order:-- ~~ - line_lbd-- ~~ - tictoc_profiler-- ~~ - detect_3d_cuboid-- ~~ - object_slam-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- +++ processing catkin package: 'line_lbd'-- ==&gt; add_subdirectory(cube_slam/line_lbd)CMake Error at /usr/share/catkin/cmake/catkinConfig.cmake:75 (find_package): Could not find a package configuration file provided by "cmake_modules" with any of the following names: cmake_modulesConfig.cmake cmake_modules-config.cmake Add the installation prefix of "cmake_modules" to CMAKE_PREFIX_PATH or set "cmake_modules_DIR" to a directory containing one of the above files. If "cmake_modules" provides a separate development package or SDK, be sure it has been installed.Call Stack (most recent call first): cube_slam/line_lbd/CMakeLists.txt:7 (find_package)-- Configuring incomplete, errors occurred!See also "/home/gpu1/cubeslam_ws/build/CMakeFiles/CMakeOutput.log".See also "/home/gpu1/cubeslam_ws/build/CMakeFiles/CMakeError.log".Invoking "cmake" failed 解决错误3：安装ROS参考连接：https://blog.csdn.net/whl970831/article/details/88097108123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ROS安装步骤1.将时间误差缩短到最小sudo apt-get install -y chrony ntpdatesudo ntpdate -q ntp.ubuntu.com2.在ros-latest.list添加ROS版本库sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt; /etc/apt/sources.list.d/ros-latest.list'3.设置公钥(Key)sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 0xB01FA116如果无法连接上述服务器，可以尝试hkp://pgp.mit.edu:80或者hkp://keyserver.ubuntu.com:804.更新软件包索引sudo apt-get updatesudo apt-get upgrade -y5.安装ROS Kinetic Kame（完整版-包括很多opencv的包之类的）sudo apt-get install ros-kinetic-desktop-full6.安装所有额外的rqt相关的功能包sudo apt-get install ros-kinetic-rqt*7.初始化rosdep 在使用ROS之前必须要初始化rosdepsudo rosdep initrosdep update8.安装rosinstall（启动roscore的核心） 在这里说一句，在配置环境变量时万万不可因错误，随意使用rm bashrc指令否则很容易造成环境丢失（虽然有找回的方法-extundelete安装），到时候可能只有重新配置了。sudo apt-get install python-rosinstall9.安装我们程序运行需要的服务sudo apt-get install ros-kinetic-serialsudo apt-get -y install ros-kinetic-slam-gmappingsudo apt-get -y install ros-kinetic-map-serversudo apt-get -y install ros-kinetic-amcl10.配置环境变量：echo “source /opt/ros/kinetic/setup.bash” &gt;&gt; ~/.bashrcsource ~/.bashrc11.测试安装结果roscore （新终端）看最后有没有setting /run_id to b243608a-2524-11e8-8f6c-342387e5d341process[rosout-1]: started with pid [7671]started core service [/rosout]有就成功了]]></content>
      <categories>
        <category>视觉slam</category>
      </categories>
      <tags>
        <tag>sube_slam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
